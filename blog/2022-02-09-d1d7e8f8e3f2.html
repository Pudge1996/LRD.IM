<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=devUIice-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

    <meta name="keywords" content="李瑞东 Pudge 广州 设计 design UI设计 体验设计 B端设计 设计作品 作品集"> 
    <meta name="author" content="李瑞东" />
    <meta name="robots" content="index,follow" />
    <meta name="google" content="index,follow" />
    <meta name="googlebot" content="index,follow" />
    <meta name="verify" content="index,follow" />
    <meta name="format-detection" content="telephone=no, email=no" />
    <!-- It may be good for SEO -->

    <title>笔记：表格宽度的计算规则 · 李瑞东 LRD.IM</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon/favicon-32x32.png">

    
    <!-- main css -->
    <link rel="stylesheet" href="../css/main.css">

    <!-- clipboard js -->
    <script src="../js/clipboard.min.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112191540-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112191540-2');
</script>

</head>
  <body>
    <!-- 导航栏-->
    <div class="container-fluid"> 
      <header class="box-header">
          <div class="vw">
          <a href="../index.html" alt="lrd.im 是设计师李瑞东的个人网站。">
              <div class="box-logo"></div>
          </a>
          <!-- nav-text -->
          <div class="nav-text-box">
              <p><a href="../project.html" class="nav-text">作品</a></p>
              <p><a href="../blog.html" class="nav-text">博客</a></p>
              <p><a href="../archive.html" class="nav-text">归档</a></p>
              <p><a href="../about.html" class="nav-text">关于我</a></p>
          </div>
          <div class="icon-menu" id="iconMenu"></div>
          <div class="icon-close hide" id="iconClose"></div>
      </div>
      </header>
  </div>
  <div class="nav-open hidden nav-transform" id="navOpen">
      <a href="../project.html">作品</a>
      <a href="../blog.html">博客</a>
      <a href="../archive.html">归档</a>
      <a href="../about.html">关于我</a>
  </div>
  <div class="nav-mask hidden" id="navMask"></div>
  <!-- end 导航栏-->
<article class="h-entry">
<header>
<h1 class="p-name">笔记：表格宽度的计算规则</h1>
<p class="article-info">Pudge · <time>2022-02-09 </time>首次发布于 <a href="https://pudge1996.medium.com/learning-table-layout-d1d7e8f8e3f2" target="_blank" class="vpn">Medium</a></p>
</header>
<section data-field="subtitle" class="p-summary">
  自从 2020 年下半年我在千聊做 B 端设计师开始，我就开始了与 Table 组件打交道。从那时候我就发现了，表格的布局，好像永远都跟我的设想不符，也很难判断到造成这个后果的原因是我提出的设计需求太奇葩，还是前端老哥压根没按我说的去还原。
  </section>
  <section data-field="body" class="e-content">
    <section  class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn">
      <!-- <figure   class="graf graf--figure graf-after--h3"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*dK3wpII1_LFUNKj6j8LDOQ.png" width="1400" height="762" data-is-featured="true" alt="封面" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/01.png"><figcaption class="imageCaption">背景图来源：<a href="https://dribbble.com/jordanhughes" data-href="https://dribbble.com/jordanhughes" class="markup--anchor markup--figure-anchor" rel="contact noopener" target="_blank">Jordan Hughes</a></figcaption></figure> -->
      <p   class="graf graf--p graf-after--figure">自从 2020 年下半年我在千聊做 B 端设计师开始，我就开始了与 Table 组件打交道。从那时候我就发现了，表格的布局，好像永远都跟我的设想不符，也很难判断到造成这个后果的原因是我提出的设计需求太奇葩，还是前端老哥压根没按我说的去还原。</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*Ky48ZXwh_XAxjuGmPqjCwg.png" width="1440" height="762" alt="截图列出常见的表格问题" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/02.png"></figure><p   class="graf graf--p graf-after--figure">直到 2021 年，我加入了欢聚集团，一样是做 B 端设计师，一样要跟 Table 组件打交道。但在这里做设计的难度更大，要考虑到更多的场景。</p><p   class="graf graf--p graf-after--p">所以我觉得不能再逃避了，自己真的要花点时间搞懂 Table 的列宽计算规则。于是我花了大概2~3周的工作之外的时间，去研究 Table 组件的布局规则，去做实践验证。</p><p   class="graf graf--p graf-after--p">下文就是我这段时间的知识结晶，从 UI 设计师的角度，阐述对 Table 布局的理解。对我来说，把研究到的东西写成文档，能再次全面地梳理和复习一遍；对读者来说，希望…有少许帮助吧~</p><h3   class="graf graf--h4 graf-after--p">必要的概念说明</h3><p   class="graf graf--p graf-after--h4">掌握表格相关的名词释义，才能理解表格的形成。在设计中我们需要时刻谨记，表格的宽度是不定的，内容宽度也是不定的，浏览器最终渲染出来的真实列宽，是多个属性共同作用下的结果。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">表格宽度 (tableWidth)：</strong></p><p   class="graf graf--p graf-after--p">table 的 width 属性。可以是自动，也可以是某个百分比或特定的值。自动宽度时，表格宽度会根据内容来改变。以下是自动宽度的三种情况：</p><ul class="postList"><li   class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">auto</code> 或不设置时，表格宽度会撑满容器（默认值）；</li><li   class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">min-content</code> 时，表格宽度是由最小单元格内容宽度的列组成；</li><li   class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">max-content</code> 时，表格宽度是由最大单元格内容宽度的列组成；</li></ul><figure   class="graf graf--figure graf-after--li"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*ZyEM5jLTzqJsXos4mqTsIA.png" width="1440" height="762" alt="以上三种情况的展示。有父容器，表格，和三种情况的内容。" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/03.png"></figure><p   class="graf graf--p graf-after--figure">当设置了自动宽度的表格，宽度到达父容器的宽度，效果就跟固定表格宽度一致了。所以自动宽度的表格， 其真实表格宽度可能是又各列撑起的宽度，也可能是父容器的宽度。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">定宽列的宽度 (fixedWidth)：</strong></p><p   class="graf graf--p graf-after--p">某列被设置的宽度，可以理解为我们平时让前端限制某列的列宽多少px，指的就是该项的值。</p><p   class="graf graf--p graf-after--p">值得一提的是，<strong class="markup--strong markup--p-strong">定宽列的宽度</strong> (fixedWidth) 会受到两个宽度的影响：列宽度 (colWidth) 和单元格宽度 (cellWidth)。不同的布局方式，有不同的影响。具体在后文会在后文写清楚。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">列宽度 (colWidth)：</strong></p><p   class="graf graf--p graf-after--p">col 标签上设置的 width 属性。也就是通过 Table 组件的 API <code class="markup--code markup--p-code">width</code> 所设置的宽度。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">单元格宽度 (cellWidth)：</strong></p><p   class="graf graf--p graf-after--p">td、th 内设置的 width 属性，也就是单元格里 div 或图片等撑起来的宽度。取较大的值。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">真实列宽 (realColWidth)：</strong></p><p   class="graf graf--p graf-after--p">通过计算后，真实展现在界面中的列宽度。也就是这篇笔记我们所探讨的内容。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">单元格内容宽度 (contentWidth)：</strong></p><p   class="graf graf--p graf-after--p">单元格里面的内容所占的宽度，单元格内容可以是文本、图片或 div 等组成。如果是文本，单元格内容宽度是这段文本排成一行所占的宽度；如果是图片，则是该图片渲染出来的真实尺寸；如果是 div，则宽度与 div 的宽度一致。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">最小单元格内容宽度 (minContentWidth)：</strong></p><p   class="graf graf--p graf-after--p">内容可以被压缩至最小的宽度。如果内容是一段中文，则该值为一个汉字的宽度；如果是一段英文，则该值为这段英文里，宽度最大的字母所占的空间；如果是 div，则该值为 div 的宽度。</p><p   class="graf graf--p graf-after--p">值得一提的是，文本的换行规则，容器的 Padding 等也会影响到该宽度的值，下图会帮助大家理解<strong class="markup--strong markup--p-strong">最小单元格内容宽度</strong>：</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*ZzLYZUi_e-va3H7bVeWtIg.png" width="1440" height="762" alt="最小内容宽度的计算" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/04.png"></figure><h3   class="graf graf--h4 graf-after--figure">两种布局方式</h3><p   class="graf graf--p graf-after--h4">table-layout 属性定义了用于布局表格单元格，行和列的算法。该属性可被配置为：</p><ul class="postList"><li   class="graf graf--li graf-after--p">table-layout: auto;（ 是 Ant Design / Arco Design / TDesign 的 Table 组件，以及 HTML &lt;table&gt; 的默认值）</li><li   class="graf graf--li graf-after--li">table-layout: fixed; （ 是 Element UI 的 Table 组件默认值）</li></ul><p   class="graf graf--p graf-after--li">两种布局方式的不同之处：</p><ul class="postList"><li   class="graf graf--li graf-after--p">auto 布局下，表格和列的宽度，会受到内容宽度的影响。比如第一列的文本比第二列的长，那么浏览器就会根据内容长度来分配列宽。</li><li   class="graf graf--li graf-after--li">fixed 布局下，表格和列的宽度，通过列宽度 (colWidth) 来设置，某一列的宽度仅由该列首行的单元格决定，所以内容不会影响列宽。用该方式布局可以使表格的渲染速度更快，因为它只需要加载第一行的内容，就能渲染出表格的宽度、布局。</li></ul><p   class="graf graf--p graf-after--li">两者之间的区别，也可以透过下图来更清楚地认识。</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*j_5UsKDtOxJ5Cpu-dEvCYg.png" width="1440" height="762" alt="auto 布局和 fixed 布局的区别" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/05.png"></figure><p   class="graf graf--p graf-after--figure">好了，接下来我们正式进入列宽计算的世界吧～</p><h3   class="graf graf--h4 graf-after--p">auto 布局的列宽计算</h3><p   class="graf graf--p graf-after--h4">在 table-layout: auto; 的布局下，影响真实列宽的有以下三种宽度：</p><ul class="postList"><li   class="graf graf--li graf-after--p">定宽列的宽度 (fixedWidth)</li><li   class="graf graf--li graf-after--li">单元格内容宽度 (contentWidth)</li><li   class="graf graf--li graf-after--li">表格宽度 (tableWidth)</li></ul><p   class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">类型1：表格中所有列都设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>表格宽度足够放下所有列时：</p><p   class="graf graf--p graf-after--p">此时表格的真实列宽，会根据每列所设定的宽度来按比例分配。</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = Math.max(colWidth, cellWidth)</code></pre>
      <pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = Math.max(fixedWidth / sum(fixedWidth) * tableWidth, minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = Math.max(tableWidth, sum(realColWidth))</code></pre><p   class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">场景B：</strong>表格宽度不足以放下所有列时：</p><p   class="graf graf--p graf-after--p">真实表格宽度会超出容器，出现横向滚动条（如有配置）。此时列宽和表格宽度的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = Math.max(colWidth, cellWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = Math.max(fixedWidth, minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = sum(realColWidth)</code></pre><p   class="graf graf--p graf-after--pre">上述两种场景的具体表现， 如下图所示：</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*bjcWVd_xp3sZmwcXSfp7iA.png" width="1440" height="762" alt="auto 的类型1" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/06.png"></figure><p   class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">类型2：表格中所有列都不设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>表格宽度足够放下所有列时：</p><p   class="graf graf--p graf-after--p">根据每列的最大内容宽度，来按比例分配列宽。如果单元格内文本没有触发换行，那么此时列宽和表格宽度的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 不定宽列的宽度<br>autoWidth = Math.max(contentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = Math.max(autoWidth / sum(autoWidth) * tableWidth, minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = Math.max(tableWidth, sum(realColWidth))</code></pre><p   class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">场景B：</strong>表格宽度不足以放下所有列时：</p><p   class="graf graf--p graf-after--p">每一列都会被压缩至最小内容宽度，并且真实表格宽度会超出容器，出现横向滚动条（如有配置）。此时列宽和表格宽度的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 不定宽列的宽度<br>autoWidth = minContentWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = autoWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = sum(realColWidth)</code></pre><p   class="graf graf--p graf-after--pre">上述两种场景的具体表现， 如下图所示：</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*XdTxt7Lnhrp_uhO34fmZWQ.png" width="1440" height="762" alt="auto 的类型2" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/07.png"></figure><p   class="graf graf--p graf-after--figure">注：如果实际情况是处于<strong class="markup--strong markup--p-strong">场景A</strong>和<strong class="markup--strong markup--p-strong">场景B</strong>之间，即单元格里的文本因为宽度挤压而出现换行，却又没被挤压到内容最小宽度时。我这还暂时没有发现到一条公式可以计算具体的宽度。换言之，上面的公式只对未出现文本换行，或所有列都被挤压到最小宽度时的表格有效。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">类型3：部分列设置宽度，部分列不设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>所有不定宽列的<strong class="markup--strong markup--p-strong">最小单元格内容宽度</strong>之和小于或等于<strong class="markup--strong markup--p-strong">减去定宽列之后的表格宽度</strong></p><p   class="graf graf--p graf-after--p">不定宽列会按照单元格内容宽度，按比例分配减去定宽列之后的表格宽度。这意味着：</p><ul class="postList"><li   class="graf graf--li graf-after--p">不定宽列的真实列宽会被按比例压缩或延长；</li><li   class="graf graf--li graf-after--li">定宽列的真实列宽，则按所设置的宽度来展示。</li></ul><p   class="graf graf--p graf-after--li">此时列宽和表格宽度的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = Math.max(colWidth, cellWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 不定宽列的宽度<br>autoWidth = Math.max(contentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 定宽列的真实列宽<br>realColFixedWidth = Math.max(fixedWidth, minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 不定宽列的真实列宽<br>realColAutoWidth = Math.max(autoWidth / sum(autoWidth) * (tableWidth - sum(realColFixedWidth)), minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = Math.max(tableWidth, sum(realColFixedWidth) + sum(realColAutoWidth))</code></pre><p   class="graf graf--p graf-after--pre">帮助理解：类型3-场景A里，计算不定宽列的真实列宽，可以把它当做类型2-场景A 来思考，只是表格宽度是不包含定宽列的真实列宽。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景B：</strong>所有不定宽列的<strong class="markup--strong markup--p-strong">最小单元格内容宽度</strong>之和大于<strong class="markup--strong markup--p-strong">减去定宽列之后的表格宽度</strong></p><p   class="graf graf--p graf-after--p">这时不定宽的列已经被压缩到无法再压缩，只能压缩定宽的列。这意味着：</p><ul class="postList"><li   class="graf graf--li graf-after--p">不定宽列的内容会以最小内容宽度来展示；</li><li   class="graf graf--li graf-after--li">定宽列，根据所设定的宽度和总定宽列的宽度，按比例压缩展示。</li></ul><p   class="graf graf--p graf-after--li">此时列宽和表格宽度的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = Math.max(colWidth, cellWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 不定宽列的宽度<br>autoWidth = Math.max(contentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">realColFixedWidth = Math.max(fixedWidth / sum(fixedWidth) * (tableWidth - sum(realColAutoWidth)), minContentWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 不定宽列的宽度<br>realColAutoWidth = minContentWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = Math.max(tableWidth, sum(realColFixedWidth) + sum(realColAutoWidth))</code></pre><p   class="graf graf--p graf-after--pre">帮助理解：类型3-场景B里，计算定宽列的真实列宽，可以把它当做类型2-场景B 来思考，只是表格宽度是不包含不定宽列的真实列宽。</p><p   class="graf graf--p graf-after--p">上述两种场景的具体表现， 如下图所示：</p><figure   class="graf graf--figure graf-after--p"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*D_JakR_Jx0H3rxGTXTj7qA.png" width="1440" height="762" alt="auto 的类型3" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/08.png"></figure><h3   class="graf graf--h4 graf-after--figure">fixed 布局的列宽计算</h3><p   class="graf graf--p graf-after--h4">在 table-layout: fixed 布局下，单元格的内容宽度，不会对表格的真实列宽产生影响。这时影响真实列宽的有以下三种宽度：</p><ul class="postList"><li   class="graf graf--li graf-after--p">列宽度 (colWidth)</li><li   class="graf graf--li graf-after--li">单元格宽度 (cellWidth)</li><li   class="graf graf--li graf-after--li">表格宽度 (tableWidth)</li></ul><p   class="graf graf--p graf-after--li">细心的网友可能发现了，colWidth 和 cellWidth 之间较大的值，就是 auto 布局里 fixedWidth 值。但在 fixed 模式中，如果某一列同时设置了 colWidth、cellWidth，优先级是 colWidth &gt; cellWidth。</p><p   class="graf graf--p graf-after--p">即在 fixed 布局下，通过 API <code class="markup--code markup--p-code">width</code> 所设置的列宽，是比在 td、th 或 div 里设置的宽度，权重要高，不需要比较两者之间的大小。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">类型1：表格中所有列都设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>表格宽度足够放下所有列时：</p><p   class="graf graf--p graf-after--p">此时表格的真实列宽，会根据每列所设定的宽度来按比例分配。计算公式如下：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = colWidth || cellWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = Math.max(fixedWidth / sum(fixedWidth) * tableWidth, fixedWidth)</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = tableWidth</code></pre><p   class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">场景B：</strong>表格宽度不足以放下所有列时：</p><p   class="graf graf--p graf-after--p">此时表格的真实列宽，与每列所设定的宽度一致。真实表格宽度会超出容器，出现横向滚动条（如有配置）。计算公式如下：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = colWidth || cellWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = fixedWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = sum(fixedWidth)</code></pre><figure   class="graf graf--figure graf-after--pre"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*s-fr_OeBSwJ8bL8DSNkwYw.png" data-width="1440" data-height="762" alt="fixed 的类型1" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/09.png"></figure><p   class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">类型2：表格中所有列都不设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>表格宽度足够放下所有列时：</p><p   class="graf graf--p graf-after--p">所有列会等分表格的宽度。</p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景B：</strong>表格宽度不足以放下所有列时：</p><p   class="graf graf--p graf-after--p">所有列会等分表格的宽度，由于列宽不受内容控制，所以单元格内的内容有可能会溢出到单元格以外的位置。</p><p   class="graf graf--p graf-after--p">上述两个场景的计算公式：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// cols = 列数<br>// 不定宽列的宽度<br>autoWidth = tableWidth / cols</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实列宽<br>realColWidth = autoWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = tableWidth</code></pre><figure   class="graf graf--figure graf-after--pre"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*QE50QMZ9ABmjGMyFVuPFnQ.png" data-width="1440" data-height="762" alt="fixed 的类型2" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/10.png"></figure><p   class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">类型3：部分列设置宽度，部分列不设置宽度</strong></p><p   class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">场景A：</strong>表格宽度足够放下所有定宽的列时：</p><p   class="graf graf--p graf-after--p">定宽的列，真实列宽等于所设定的宽度值，不定宽的列会平分表格剩余宽度。计算公式如下：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = colWidth || cellWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 定宽列的真实列宽<br>realColFixedWidth = fixedWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// autoCols = 不定宽列的列数<br>// 不定宽列的真实列宽<br>realColAutoWidth = (tableWidth - sum(realColFixedWidth)) / autoCols</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = tableWidth</code></pre><p   class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">场景B：</strong>表格宽度不足以放下所有定宽的列时：</p><p   class="graf graf--p graf-after--p">真实表格宽度会超出容器，出现横向滚动条（如有配置）。超出表格宽度的列，都会游离在表格组件以外。如果该列是定宽列，则保持原有宽度；如果该列是不定宽列，则单元格被挤压至最小内容宽度。计算公式如下：</p><pre   class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">// 定宽列的宽度<br>fixedWidth = colWidth || cellWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 定宽列的真实列宽<br>realColFixedWidth = fixedWidth</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 不定宽列的真实列宽<br>realColAutoWidth = 0</code></pre><pre   class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">// 真实表格宽度<br>realTableWidth = tableWidth</code></pre><figure   class="graf graf--figure graf-after--pre"><img class="graf-image lazyload" data-action="zoom" data-image-id="1*VfrhOZim688bfecodka8tQ.png" data-width="1440" data-height="762" alt="fixed 的类型3" src="https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/11.png"></figure><h3   class="graf graf--h4 graf-after--figure">感想</h4><p   class="graf graf--p graf-after--h4">呜呼！花了大半天时间来列出表格在两种布局，六种类型，十二种场景下的列宽规则，终于把前段时间学在脑子内的知识写成文档了。这篇文章应该是我写过比较硬核的一篇了，通篇都是理论。</p><p   class="graf graf--p graf-after--p">重要的是，这些理论知识，应用在 Ant Design、Arco Design、Element UI 等主流的组件库，都是适用的，因为这些表格组件都是在 HTML 的 &lt;table&gt; 基础上完成的。</p><p   class="graf graf--p graf-after--p">耐人寻味的一点是，我在2021年年初对 <a href="https://lrd.im/blog/2021-03-14-56a375c11043.html" data-href="https://lrd.im/blog/2021-03-14-56a375c11043.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Web 换行规则的探索</a>，来到表格组件上也有发挥的空间，它帮助了我理解 “最小单元格内容宽度” 。所以不得不说，网页设计上的知识，真是环环相扣，让我有源源不断的学习动力。</p><p   class="graf graf--p graf-after--p">之后的文章可能会写点实例。比如在不同业务场景下，应该使用哪种布局，或应该怎么给单元格设定规则。毕竟理论知识，需要在实际的业务场景里面验证、总结出实例，才算一个完整的学习过程。</p><h3   class="graf graf--h4 graf-after--p">参考文章</h3><div   class="graf graf--mixtapeEmbed graf-after--h4"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout" data-href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout"><strong class="markup--strong markup--mixtapeEmbed-strong">table-layout - CSS（层叠样式表） | MDN</strong><br><em class="markup--em markup--mixtapeEmbed-em">table-layout CSS属性定义了用于布局表格单元格，行和列的算法。</em>developer.mozilla.org</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/table-layout" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d67474b782fcb19fd49dccbd86c586b1" data-thumbnail-img-id="0*wDpn7DI2uLiZHP9w" style="background-image: url(https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/12.png);"></a></div><div   class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://zhuanlan.zhihu.com/p/137218174" data-href="https://zhuanlan.zhihu.com/p/137218174" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://zhuanlan.zhihu.com/p/137218174"><strong class="markup--strong markup--mixtapeEmbed-strong">Antd Table布局指南</strong><br><em class="markup--em markup--mixtapeEmbed-em">在使用Antd ...</em>zhuanlan.zhihu.com</a></div><div   class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://ant.design/components/table-cn/#API" data-href="https://ant.design/components/table-cn/#API" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://ant.design/components/table-cn/#API"><strong class="markup--strong markup--mixtapeEmbed-strong">表格 Table - Ant Design</strong><br><em class="markup--em markup--mixtapeEmbed-em">展示行列数据。</em>ant.design</a><a href="https://ant.design/components/table-cn/#API" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b6b5232d0d66b96c7f7021d7ccba5369" data-thumbnail-img-id="0*CbKPN7Ccb398-tK1" style="background-image: url(https://lrdim.oss-cn-shenzhen.aliyuncs.com/blogimg/2022-02-09-d1d7e8f8e3f2/14.png);"></a></div><div   class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://www.cnblogs.com/guozhaodong/p/6892935.html" data-href="https://www.cnblogs.com/guozhaodong/p/6892935.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.cnblogs.com/guozhaodong/p/6892935.html"><strong class="markup--strong markup--mixtapeEmbed-strong">关于html表格单元格宽度的计算规则</strong><br><em class="markup--em markup--mixtapeEmbed-em">表格单元格宽度的计算方式主要分为两种方式： 固定表格布局、自动表格布局，…</em>www.cnblogs.com</a></div></div></div></section>
    </section>
<hr class="end-dividers hr-1" data-content="分隔线">

<div class="article-navigation">
  <a href="2022-01-17-8a5738fc2340.html" class="previous">
      <p>上一篇</p>
      <p class="title">细数 Pingfang SC 的七宗罪</p>
  </a>
  <a href="2022-05-14-e0efbeed2ca0.html" class="next">
    <p>下一篇</p>
    <p class="title">高级排版功能：Case-Sensitive Forms 是什么？</p>
  </a>
</div>

<hr class="end-dividers hr-2" data-content="分隔线">

<div class="footer-action">
  <div class="back-to-article"><a href="../blog.html"><span class="icon-back"></span>博客首页</a></div>
  <div class="copy-link" id="copyLink"><a href="javascript:" id="blogLink" data-clipboard-text="笔记：表格宽度的计算规则 https://lrd.im/blog/2022-02-09-d1d7e8f8e3f2.html" ><span class="icon-link"></span>复制链接</a></div>
  <div class="copied hide" id="copied"><a href="javascript:" data-clipboard-text="笔记：表格宽度的计算规则 https://lrd.im/blog/2022-02-09-d1d7e8f8e3f2.html"><span class="icon-success"></span>复制成功!</a></div>
  <div class="mobile-top"><a href="#" onclick="backToTop(4)"><span class="icon-top"></span>回到顶部</a></div>
</div>

<!-- back to top -->
<div id="sideButton">
  <div class="side-button to-top" id="toTop" onclick="backToTop(4)">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="#232323">
          <path d="M277.375 427V167.296l119.702 119.702L427 256 256 85 85 256l29.924 29.922 119.701-118.626V427h42.75z"/>
      </svg>
  </div>
</div>
<!-- end back to top -->

<!-- footer -->
<footer>
  <p class="copyright">© Pudge 2017-2022</p>
</footer>

<!-- end footer -->
</article>
<script src="https://cdn.jsdelivr.net/npm/zoom-vanilla.js/dist/zoom-vanilla.min.js"></script>
<script src="../js/lazysizes.min.js"></script>
<script src="../js/custom.js"></script>
</body>
</html>